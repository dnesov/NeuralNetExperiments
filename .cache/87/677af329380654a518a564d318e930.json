{"id":"node_modules/brain.js/dist/recurrent/matrix/index.js","dependencies":[{"name":"C:\\Users\\dnesov\\Documents\\GitHub\\NeuralNetExperiments\\node_modules\\brain.js\\dist\\recurrent\\matrix\\index.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\dnesov\\Documents\\GitHub\\NeuralNetExperiments\\package.json","includedInParent":true,"mtime":1555160889145},{"name":"C:\\Users\\dnesov\\Documents\\GitHub\\NeuralNetExperiments\\node_modules\\brain.js\\package.json","includedInParent":true,"mtime":1555160889068},{"name":"../../utilities/zeros","loc":{"line":9,"column":21},"parent":"C:\\Users\\dnesov\\Documents\\GitHub\\NeuralNetExperiments\\node_modules\\brain.js\\dist\\recurrent\\matrix\\index.js","resolved":"C:\\Users\\dnesov\\Documents\\GitHub\\NeuralNetExperiments\\node_modules\\brain.js\\dist\\utilities\\zeros.js"}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _zeros = require('../../utilities/zeros');\n\nvar _zeros2 = _interopRequireDefault(_zeros);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A matrix\n * @param {Number} [rows]\n * @param {Number} [columns]\n * @constructor\n */\nvar Matrix = function () {\n  function Matrix(rows, columns) {\n    _classCallCheck(this, Matrix);\n\n    if (rows === undefined) return;\n    if (columns === undefined) return;\n\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = (0, _zeros2.default)(rows * columns);\n    this.deltas = (0, _zeros2.default)(rows * columns);\n  }\n\n  /**\n   *\n   * @param {Number} row\n   * @param {Number} col\n   * @returns {Float32Array|Array}\n   */\n\n\n  _createClass(Matrix, [{\n    key: 'getWeights',\n    value: function getWeights(row, col) {\n      // slow but careful accessor function\n      // we want row-major order\n      var ix = this.columns * row + col;\n      if (ix < 0 && ix >= this.weights.length) throw new Error('get accessor is skewed');\n      return this.weights[ix];\n    }\n\n    /**\n     *\n     * @param {Number} row\n     * @param {Number} col\n     * @param v\n     * @returns {Matrix}\n     */\n\n  }, {\n    key: 'setWeight',\n    value: function setWeight(row, col, v) {\n      // slow but careful accessor function\n      var ix = this.columns * row + col;\n      if (ix < 0 && ix >= this.weights.length) throw new Error('set accessor is skewed');\n      this.weights[ix] = v;\n    }\n\n    /**\n     *\n     * @param {Number} row\n     * @param {Number} col\n     * @param v\n     * @returns {Matrix}\n     */\n\n  }, {\n    key: 'setDeltas',\n    value: function setDeltas(row, col, v) {\n      // slow but careful accessor function\n      var ix = this.columns * row + col;\n      if (ix < 0 && ix >= this.weights.length) throw new Error('set accessor is skewed');\n      this.deltas[ix] = v;\n    }\n\n    /**\n     *\n     * @returns {{rows: *, columns: *, weights: Array}}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return {\n        rows: this.rows,\n        columns: this.columns,\n        weights: this.weights.slice(0)\n      };\n    }\n  }, {\n    key: 'weightsToArray',\n    value: function weightsToArray() {\n      var deltas = [];\n      var row = 0;\n      var column = 0;\n      for (var i = 0; i < this.weights.length; i++) {\n        if (column === 0) {\n          deltas.push([]);\n        }\n        deltas[row].push(this.weights[i]);\n        column++;\n        if (column >= this.columns) {\n          column = 0;\n          row++;\n        }\n      }\n      return deltas;\n    }\n  }, {\n    key: 'deltasToArray',\n    value: function deltasToArray() {\n      var deltas = [];\n      var row = 0;\n      var column = 0;\n      for (var i = 0; i < this.deltas.length; i++) {\n        if (column === 0) {\n          deltas.push([]);\n        }\n        deltas[row].push(this.deltas[i]);\n        column++;\n        if (column >= this.columns) {\n          column = 0;\n          row++;\n        }\n      }\n      return deltas;\n    }\n  }], [{\n    key: 'fromJSON',\n    value: function fromJSON(json) {\n      var matrix = new Matrix(json.rows, json.columns);\n      for (var i = 0, max = json.rows * json.columns; i < max; i++) {\n        matrix.weights[i] = json.weights[i]; // copy over weights\n      }\n      return matrix;\n    }\n\n    /**\n     *\n     * @param weightRows\n     * @param [deltasRows]\n     * @returns {Matrix}\n     */\n\n  }, {\n    key: 'fromArray',\n    value: function fromArray(weightRows, deltasRows) {\n      var rows = weightRows.length;\n      var columns = weightRows[0].length;\n      var m = new Matrix(rows, columns);\n\n      deltasRows = deltasRows || weightRows;\n\n      for (var rowIndex = 0; rowIndex < rows; rowIndex++) {\n        var weightValues = weightRows[rowIndex];\n        var deltasValues = deltasRows[rowIndex];\n        for (var columnIndex = 0; columnIndex < columns; columnIndex++) {\n          m.setWeight(rowIndex, columnIndex, weightValues[columnIndex]);\n          m.setDeltas(rowIndex, columnIndex, deltasValues[columnIndex]);\n        }\n      }\n\n      return m;\n    }\n  }]);\n\n  return Matrix;\n}();\n\nexports.default = Matrix;\n","map":{"version":3,"sources":["../../../src/recurrent/matrix/index.js"],"names":["Matrix","rows","columns","undefined","weights","deltas","row","col","ix","length","Error","v","slice","column","i","push","json","matrix","max","weightRows","deltasRows","m","rowIndex","weightValues","deltasValues","columnIndex","setWeight","setDeltas"],"mappings":"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","file":"index.js","sourcesContent":["import zeros from '../../utilities/zeros';\n\n/**\n * A matrix\n * @param {Number} [rows]\n * @param {Number} [columns]\n * @constructor\n */\nexport default class Matrix {\n  constructor(rows, columns) {\n    if (rows === undefined) return;\n    if (columns === undefined) return;\n\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = zeros(rows * columns);\n    this.deltas = zeros(rows * columns);\n  }\n\n  /**\n   *\n   * @param {Number} row\n   * @param {Number} col\n   * @returns {Float32Array|Array}\n   */\n  getWeights(row, col) {\n    // slow but careful accessor function\n    // we want row-major order\n    let ix = (this.columns * row) + col;\n    if (ix < 0 && ix >= this.weights.length) throw new Error('get accessor is skewed');\n    return this.weights[ix];\n  }\n\n  /**\n   *\n   * @param {Number} row\n   * @param {Number} col\n   * @param v\n   * @returns {Matrix}\n   */\n  setWeight(row, col, v) {\n    // slow but careful accessor function\n    let ix = (this.columns * row) + col;\n    if (ix < 0 && ix >= this.weights.length) throw new Error('set accessor is skewed');\n    this.weights[ix] = v;\n  }\n\n  /**\n   *\n   * @param {Number} row\n   * @param {Number} col\n   * @param v\n   * @returns {Matrix}\n   */\n  setDeltas(row, col, v) {\n    // slow but careful accessor function\n    let ix = (this.columns * row) + col;\n    if (ix < 0 && ix >= this.weights.length) throw new Error('set accessor is skewed');\n    this.deltas[ix] = v;\n  }\n\n  /**\n   *\n   * @returns {{rows: *, columns: *, weights: Array}}\n   */\n  toJSON() {\n    return {\n      rows: this.rows,\n      columns: this.columns,\n      weights: this.weights.slice(0)\n    };\n  }\n\n  static fromJSON(json) {\n    let matrix = new Matrix(json.rows, json.columns);\n    for (let i = 0, max = json.rows * json.columns; i < max; i++) {\n      matrix.weights[i] = json.weights[i]; // copy over weights\n    }\n    return matrix;\n  }\n\n  /**\n   *\n   * @param weightRows\n   * @param [deltasRows]\n   * @returns {Matrix}\n   */\n  static fromArray(weightRows, deltasRows) {\n    const rows = weightRows.length;\n    const columns = weightRows[0].length;\n    const m = new Matrix(rows, columns);\n\n    deltasRows = deltasRows || weightRows;\n\n    for (let rowIndex = 0; rowIndex < rows; rowIndex++) {\n      const weightValues = weightRows[rowIndex];\n      const deltasValues = deltasRows[rowIndex];\n      for (let columnIndex = 0; columnIndex < columns; columnIndex++) {\n        m.setWeight(rowIndex, columnIndex, weightValues[columnIndex]);\n        m.setDeltas(rowIndex, columnIndex, deltasValues[columnIndex]);\n      }\n    }\n\n    return m;\n  }\n\n  weightsToArray() {\n    const deltas = [];\n    let row = 0;\n    let column = 0;\n    for (let i = 0; i < this.weights.length; i++) {\n      if (column === 0) {\n        deltas.push([]);\n      }\n      deltas[row].push(this.weights[i]);\n      column++;\n      if (column >= this.columns) {\n        column = 0;\n        row++;\n      }\n    }\n    return deltas;\n  }\n\n  deltasToArray() {\n    const deltas = [];\n    let row = 0;\n    let column = 0;\n    for (let i = 0; i < this.deltas.length; i++) {\n      if (column === 0) {\n        deltas.push([]);\n      }\n      deltas[row].push(this.deltas[i]);\n      column++;\n      if (column >= this.columns) {\n        column = 0;\n        row++;\n      }\n    }\n    return deltas;\n  }\n}\n"]}},"hash":"c860ec92c917498a959239714d6aeb20","cacheData":{"env":{}}}